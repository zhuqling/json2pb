#!/usr/bin/env node
'use strict';
var Json2pb = require(__dirname+"/../lib/json2pb.js");

var mod_getopt = require('posix-getopt'),
    pkg     = require('../package.json'),
    cofs = require('co-fs'),
    co = require('co'),
    ProtoBuf = require("protobufjs");

function version()
{
    console.log("%s version %s", pkg['name'], pkg['version']);
}

function usage()
{
    console.error("Usage: %s [options] files\n", pkg['name']);
    console.error("Use %s --help for a list of options", pkg['name']);
}

function help()
{
    console.error("Usage: %s [options] files", pkg['name']);
    console.error("Options:");
    console.error("  -h, --help                   Display this information.");
    console.error("  -v, --version                Print the compiler version.");
    console.error("  -o, --output                 Encode to the file.");
    console.error("  -m, --message                Set the message to be built.");
    console.error("  -p, --proto                  Specify the protobuf's .proto file.");
}

function* main(argv) {
    var parser, option;
    var output_file = null;
    var message = null;
    var builder = ProtoBuf.newBuilder({ convertFieldsToCamelCase: false });

    parser = new mod_getopt.BasicParser('v(version)h(help)o:(output)m:(message)p:(proto)', argv);
    while ((option = parser.getopt()) !== undefined) {
        switch (option.option) {
            case 'v':
                version();
                return 0;
            case 'h':
                help();
                return 0;
            case 'o':
                output_file = option.optarg;
                break;
            case 'm':
                message = option.optarg;
                break;
            case 'p':
                ProtoBuf.loadProtoFile(option.optarg, builder);
                break;
            default:
                /* error message already emitted by getopt */
                return 1;
        }
    }

    if (parser.optind() >= argv.length) {
        console.error('Missing required argument: "file"');
        usage();
        return 1;
    }

    if(message == null) {
        console.error('Missing --message=[messsage to be built].');
        usage();
        return 1;
    }

    var root = builder.build();
    if(root == null)
    {
        console.error('Missing --proto=[protobuf .proto file].');
        usage();
        return 1;
    }


    var json2pb = new Json2pb();
    for(var i = parser.optind(); i < argv.length; ++i) {
        var input_file = argv[i];
        if(output_file == null) {
            if (input_file.substring(input_file.length - 5, input_file.length) == '.json') {
                output_file = input_file.substring(0, input_file.length - 5) + '.pb';
            } else {
                output_file = input_file + '.pb';
            }
        }

        var str = yield cofs.readFile(input_file, 'utf8');

        //var jo = JSON.parse(str);
        var T = root[message];
        /*
        T.prototype.$set = function(keyOrObj, value, noAssert) {
            return T.prototype.set.call(this, keyOrObj, value, true);
        };
        T.prototype.$add = function(keyOrObj, value, noAssert) {
            return T.prototype.add.call(this, keyOrObj, value, true);
        };
        */
        //var pbobj = yield json2pb.jsonDecode(jo, T);
        var pbobj = T.decodeJSON(str);
        var byteBuffer = pbobj.encode();
        var buffer = byteBuffer.toBuffer();
        yield cofs.writeFile(output_file, buffer);
        yield cofs.chmod(output_file, 438);
    }

    return 0;
};

co(function* () {
    var result = yield main(process.argv);
    return result;
}).then(function (result) {
    process.exit(result);
}, function (err) {
    if(err.json2pb) {
        console.error(err.json2pb.obj);
    }
    console.error(err.stack);
    console.error(err.message);
    process.exit(1);
});
